% plotMeanKernels.m
%
% Function to plot all kernels, where those relating the same variables in
%  the same direction are plotted on the same subplot. I.e. the yaw
%  velocity forward kernel for left, right, sum, and diff. Also shows
%  variance explained and number of flies in figure legend. Produces 1 
%  plot, with subplots.
% Requires the structs generated by extractKernels()
%
% INPUT:
%   kernels - kernels struct from extractKernels()
%   kernelParams - kernel parameters struct
%   whichEphys - string for which ephys parameter to plot (spikeRate or
%       medFiltV)
%   allYLims - cell array of yLims for all subplots, if [], let matlab
%       scale
%   yLbls - y-labels for all subplots
%   ttl - title for whole plot
%   degPerMM - conversion factor between mm and degrees; if 0, don't convert
%   withSEM - boolean for whether to include error shading
%   withIndiv - boolean for whether to include individual flies
%   flipRev - boolean for whether to flip reverse kernel time basis
%
% OUTPUT:
%   f - handle to figure
%   also produces plot
%
% CREATED: 8/28/19 - HHY
% UPDATED: 
%   8/29/19 - HHY
%   9/28/20 - HHY
%

function f = plotMeanKernels(kernels, kernelParams, whichEphys, ...
    allYLims, ttl, yLbls, degPerMM, withSEM, withIndiv, flipRev)
    % get all fields in kernels struct (which kernels computed)
    kFN = fieldnames(kernels);

    numSubplots = length(kFN);
    subplotRows = 2;
    subplotCols = ceil(numSubplots/subplotRows);
    
    % check if user provided yLims
    useYLims = ~isempty(allYLims);
    
    f = figure('units','normalized','outerposition',[0 0 1 1]);
    cmap = colormap('lines'); % get colormap
    
    for i = 1:numSubplots
        whichSubplot = i;
        
        % optionally flip axis for reverse kernels
        if ((kFN{i}(1) == 'r') && flipRev)
            lags = -1 * kernelParams.t;
        else
            lags = kernelParams.t;
        end
            
        
        subplot(subplotRows, subplotCols, whichSubplot);
        hold on;
        
        cFN = whichEphys;
        
        
        if (degPerMM) && ...
                (~isempty(strfind(kFN{i},'Fwd'))||...
                ~isempty(strfind(kFN{i},'Slide')))
            if (kFN{i}(1) == 'r') 
                meanKernel = kernels.(kFN{i}).(cFN).meanKernel .* degPerMM;
                sem = kernels.(kFN{i}).(cFN).sem .* degPerMM;
                allKernels = kernels.(kFN{i}).(cFN).allKernels .* degPerMM;
            elseif (kFN{i}(1) == 'f')
                meanKernel = kernels.(kFN{i}).(cFN).meanKernel ./ degPerMM;
                sem = kernels.(kFN{i}).(cFN).sem ./ degPerMM;
                allKernels = kernels.(kFN{i}).(cFN).allKernels ./ degPerMM;
            end
        else
            meanKernel = kernels.(kFN{i}).(cFN).meanKernel;
            sem = kernels.(kFN{i}).(cFN).sem;
            allKernels = kernels.(kFN{i}).(cFN).allKernels;
        end

        if withSEM
            lineHand = plot_err_patch_v2(lags, meanKernel, sem, ...
                cmap(1,:) * 0.8, cmap(1,:));
        else
            lineHand = plot(lags, meanKernel, 'Color', ...
                cmap(1,:), 'LineWidth', 1.5);
        end

        hold on;

        if withIndiv
            plot(lags, allKernels, 'Color', cmap(1,:), ...
                'LineWidth', 0.3);
        end

        legendTxt = sprintf('%s %.2f (%d)', cFN, ...
            mean(kernels.(kFN{i}).(cFN).varExpl), ...
            kernels.(kFN{i}).(cFN).numFlies);

        xlabel('Time (s)');
        xlim([-1*kernelParams.winLen kernelParams.winLen]*0.6);

        if (useYLims)
            y = allYLims{i};
        else
            y = ylim;
        end
        
        % x-axis line
        line([-1*kernelParams.winLen kernelParams.winLen], [0,0],...
            'Color', 'black');
        
        % y-axis line
        line([0,0], y, 'Color', 'black');
        ylim(y);
        ylabel(yLbls{i});
        
        title(kFN{i});
        legend(lineHand, legendTxt, 'Location', 'best');
       
        
    end
    
    suptitle(ttl);
    
end